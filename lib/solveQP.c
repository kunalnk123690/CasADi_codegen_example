/* This file was automatically generated by CasADi 3.6.6.
 *  It consists of: 
 *   1) content generated by CasADi runtime: not copyrighted
 *   2) template code copied from CasADi source: permissively licensed (MIT-0)
 *   3) user code: owned by the user
 *
 */
#ifdef __cplusplus
extern "C" {
#endif

/* How to prefix internal symbols */
#ifdef CASADI_CODEGEN_PREFIX
  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)
  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID
  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)
#else
  #define CASADI_PREFIX(ID) solveQP_ ## ID
#endif

#include <math.h>
#include <osqp/osqp.h>

#ifndef casadi_real
#define casadi_real double
#endif

#ifndef casadi_int
#define casadi_int long long int
#endif

#ifndef CASADI_MAX_NUM_THREADS
#define CASADI_MAX_NUM_THREADS 1
#endif

#include <casadi/mem.h>

/* Add prefix to internal symbols */
#define casadi_clear CASADI_PREFIX(clear)
#define casadi_copy CASADI_PREFIX(copy)
#define casadi_f0 CASADI_PREFIX(f0)
#define casadi_f1 CASADI_PREFIX(f1)
#define casadi_f2 CASADI_PREFIX(f2)
#define casadi_f3 CASADI_PREFIX(f3)
#define casadi_f3_alloc_mem CASADI_PREFIX(f3_alloc_mem)
#define casadi_f3_init_mem CASADI_PREFIX(f3_init_mem)
#define casadi_f3_mem CASADI_PREFIX(f3_mem)
#define casadi_f3_mem_counter CASADI_PREFIX(f3_mem_counter)
#define casadi_f3_unused_stack CASADI_PREFIX(f3_unused_stack)
#define casadi_f3_unused_stack_counter CASADI_PREFIX(f3_unused_stack_counter)
#define casadi_f4 CASADI_PREFIX(f4)
#define casadi_f5 CASADI_PREFIX(f5)
#define casadi_fill CASADI_PREFIX(fill)
#define casadi_mtimes CASADI_PREFIX(mtimes)
#define casadi_s0 CASADI_PREFIX(s0)
#define casadi_s1 CASADI_PREFIX(s1)
#define casadi_s10 CASADI_PREFIX(s10)
#define casadi_s11 CASADI_PREFIX(s11)
#define casadi_s12 CASADI_PREFIX(s12)
#define casadi_s13 CASADI_PREFIX(s13)
#define casadi_s2 CASADI_PREFIX(s2)
#define casadi_s3 CASADI_PREFIX(s3)
#define casadi_s4 CASADI_PREFIX(s4)
#define casadi_s5 CASADI_PREFIX(s5)
#define casadi_s6 CASADI_PREFIX(s6)
#define casadi_s7 CASADI_PREFIX(s7)
#define casadi_s8 CASADI_PREFIX(s8)
#define casadi_s9 CASADI_PREFIX(s9)
#define casadi_tri_project CASADI_PREFIX(tri_project)

/* Symbol visibility in DLLs */
#ifndef CASADI_SYMBOL_EXPORT
  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
    #if defined(STATIC_LINKED)
      #define CASADI_SYMBOL_EXPORT
    #else
      #define CASADI_SYMBOL_EXPORT __declspec(dllexport)
    #endif
  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
    #define CASADI_SYMBOL_EXPORT __attribute__ ((visibility ("default")))
  #else
    #define CASADI_SYMBOL_EXPORT
  #endif
#endif

void casadi_clear(casadi_real* x, casadi_int n) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = 0;
  }
}

void casadi_copy(const casadi_real* x, casadi_int n, casadi_real* y) {
  casadi_int i;
  if (y) {
    if (x) {
      for (i=0; i<n; ++i) *y++ = *x++;
    } else {
      for (i=0; i<n; ++i) *y++ = 0.;
    }
  }
}

void casadi_mtimes(const casadi_real* x, const casadi_int* sp_x, const casadi_real* y, const casadi_int* sp_y, casadi_real* z, const casadi_int* sp_z, casadi_real* w, casadi_int tr) {
  casadi_int ncol_x, ncol_y, ncol_z, cc;
  const casadi_int *colind_x, *row_x, *colind_y, *row_y, *colind_z, *row_z;
  ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;
  ncol_z = sp_z[1];
  colind_z = sp_z+2; row_z = sp_z + 2 + ncol_z+1;
  if (tr) {
    for (cc=0; cc<ncol_z; ++cc) {
      casadi_int kk;
      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {
        w[row_y[kk]] = y[kk];
      }
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        casadi_int kk1;
        casadi_int rr = row_z[kk];
        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {
          z[kk] += x[kk1] * w[row_x[kk1]];
        }
      }
    }
  } else {
    for (cc=0; cc<ncol_y; ++cc) {
      casadi_int kk;
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        w[row_z[kk]] = z[kk];
      }
      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {
        casadi_int kk1;
        casadi_int rr = row_y[kk];
        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {
          w[row_x[kk1]] += x[kk1]*y[kk];
        }
      }
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        z[kk] = w[row_z[kk]];
      }
    }
  }
}

#ifndef casadi_inf
  #define casadi_inf INFINITY
#endif

void casadi_fill(casadi_real* x, casadi_int n, casadi_real alpha) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = alpha;
  }
}

void casadi_tri_project(const casadi_real* x, const casadi_int* sp_x, casadi_real* y, casadi_int lower) {
  casadi_int ncol_x, j, k;
  const casadi_int *colind_x, *row_x;
  ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;
  for (j=0; j<ncol_x; ++j) {
    for (k=colind_x[j]; k<colind_x[j+1]; ++k) {
      if (lower) {
        if (row_x[k]>=j) *y++ = x ? x[k] : 0;
      } else {
        if (row_x[k]<=j) *y++ = x ? x[k] : 0;
      }
    }
  }
}

static int casadi_f3_mem_counter = 0;
static int casadi_f3_unused_stack_counter = -1;
static int casadi_f3_unused_stack[CASADI_MAX_NUM_THREADS];
static OSQPWorkspace* casadi_f3_mem[CASADI_MAX_NUM_THREADS];

#ifndef casadi_nan
  #define casadi_nan NAN
#endif

static const casadi_int casadi_s0[7] = {1, 2, 0, 1, 2, 0, 0};
static const casadi_int casadi_s1[9] = {2, 2, 0, 2, 4, 0, 1, 0, 1};
static const casadi_int casadi_s2[6] = {1, 2, 0, 1, 1, 0};
static const casadi_int casadi_s3[6] = {1, 2, 0, 0, 1, 0};
static const casadi_int casadi_s4[7] = {3, 1, 0, 3, 0, 1, 2};
static const casadi_int casadi_s5[5] = {2, 1, 0, 1, 0};
static const casadi_int casadi_s6[11] = {3, 2, 0, 3, 6, 0, 1, 2, 0, 1, 2};
static const casadi_int casadi_s7[5] = {2, 1, 0, 1, 1};
static const casadi_int casadi_s8[3] = {0, 3, 6};
static const casadi_int casadi_s9[8] = {0, 2, 3, 4, 1, 2, 3, 4};
static const casadi_int casadi_s10[3] = {0, 4, 8};
static const casadi_int casadi_s11[3] = {0, 0, 1};
static const casadi_int casadi_s12[3] = {0, 1, 3};
static const casadi_int casadi_s13[6] = {2, 1, 0, 2, 0, 1};

/* solver_qp:(i0[2],i1[15])->(o0[2x2],o1[2],o2[3x2],o3[3],o4[0x2],o5[]) */
static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j;
  casadi_real *rr, *ss;
  const casadi_real *cs;
  casadi_real *w0=w+3, *w1=w+7, w2, *w3=w+10, *w4=w+14, w5, *w6=w+17, *w7=w+21, *w8=w+27, *w9=w+30;
  /* #0: @0 = zeros(2x2) */
  casadi_clear(w0, 4);
  /* #1: @1 = zeros(1x2) */
  casadi_clear(w1, 2);
  /* #2: @2 = all_0.5(1x2,1nz) */
  w2 = 5.0000000000000000e-01;
  /* #3: @3 = input[1][0] */
  casadi_copy(arg[1], 4, w3);
  /* #4: @1 = mac(@2,@3,@1) */
  casadi_mtimes((&w2), casadi_s2, w3, casadi_s1, w1, casadi_s0, w, 0);
  /* #5: @1 = @1' */
  /* #6: @2 = 0.5 */
  w2 = 5.0000000000000000e-01;
  /* #7: @4 = zeros(1x2) */
  casadi_clear(w4, 2);
  /* #8: @5 = ones(1x2,1nz) */
  w5 = 1.;
  /* #9: @6 = @3' */
  for (i=0, rr=w6, cs=w3; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;
  /* #10: @4 = mac(@5,@6,@4) */
  casadi_mtimes((&w5), casadi_s2, w6, casadi_s1, w4, casadi_s0, w, 0);
  /* #11: @4 = (@2*@4) */
  for (i=0, rr=w4, cs=w4; i<2; ++i) (*rr++)  = (w2*(*cs++));
  /* #12: @4 = @4' */
  /* #13: @1 = (@1+@4) */
  for (i=0, rr=w1, cs=w4; i<2; ++i) (*rr++) += (*cs++);
  /* #14: (@0[:2] = @1) */
  for (rr=w0+0, ss=w1; rr!=w0+2; rr+=1) *rr = *ss++;
  /* #15: (@0[:4:2] = @1) */
  for (rr=w0+0, ss=w1; rr!=w0+4; rr+=2) *rr = *ss++;
  /* #16: @1 = zeros(1x2) */
  casadi_clear(w1, 2);
  /* #17: @5 = all_0.5(1x2,1nz) */
  w5 = 5.0000000000000000e-01;
  /* #18: @1 = mac(@5,@3,@1) */
  casadi_mtimes((&w5), casadi_s3, w3, casadi_s1, w1, casadi_s0, w, 0);
  /* #19: @1 = @1' */
  /* #20: @4 = zeros(1x2) */
  casadi_clear(w4, 2);
  /* #21: @5 = ones(1x2,1nz) */
  w5 = 1.;
  /* #22: @4 = mac(@5,@6,@4) */
  casadi_mtimes((&w5), casadi_s3, w6, casadi_s1, w4, casadi_s0, w, 0);
  /* #23: @4 = (@2*@4) */
  for (i=0, rr=w4, cs=w4; i<2; ++i) (*rr++)  = (w2*(*cs++));
  /* #24: @4 = @4' */
  /* #25: @1 = (@1+@4) */
  for (i=0, rr=w1, cs=w4; i<2; ++i) (*rr++) += (*cs++);
  /* #26: (@0[2:4] = @1) */
  for (rr=w0+2, ss=w1; rr!=w0+4; rr+=1) *rr = *ss++;
  /* #27: (@0[1:5:2] = @1) */
  for (rr=w0+1, ss=w1; rr!=w0+5; rr+=2) *rr = *ss++;
  /* #28: @6 = @0' */
  for (i=0, rr=w6, cs=w0; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;
  /* #29: output[0][0] = @6 */
  casadi_copy(w6, 4, res[0]);
  /* #30: @1 = input[1][1] */
  casadi_copy(arg[1] ? arg[1]+4 : 0, 2, w1);
  /* #31: output[1][0] = @1 */
  casadi_copy(w1, 2, res[1]);
  /* #32: @7 = zeros(2x3) */
  casadi_clear(w7, 6);
  /* #33: @8 = zeros(3x1) */
  casadi_clear(w8, 3);
  /* #34: @9 = input[1][2] */
  casadi_copy(arg[1] ? arg[1]+6 : 0, 6, w9);
  /* #35: @2 = ones(2x1,1nz) */
  w2 = 1.;
  /* #36: @8 = mac(@9,@2,@8) */
  casadi_mtimes(w9, casadi_s6, (&w2), casadi_s5, w8, casadi_s4, w, 0);
  /* #37: @8 = (-@8) */
  for (i=0, rr=w8, cs=w8; i<3; ++i) *rr++ = (- *cs++ );
  /* #38: (@7[:6:2] = @8) */
  for (rr=w7+0, ss=w8; rr!=w7+6; rr+=2) *rr = *ss++;
  /* #39: @8 = zeros(3x1) */
  casadi_clear(w8, 3);
  /* #40: @2 = ones(2x1,1nz) */
  w2 = 1.;
  /* #41: @8 = mac(@9,@2,@8) */
  casadi_mtimes(w9, casadi_s6, (&w2), casadi_s7, w8, casadi_s4, w, 0);
  /* #42: @8 = (-@8) */
  for (i=0, rr=w8, cs=w8; i<3; ++i) *rr++ = (- *cs++ );
  /* #43: (@7[1:7:2] = @8) */
  for (rr=w7+1, ss=w8; rr!=w7+7; rr+=2) *rr = *ss++;
  /* #44: @9 = @7' */
  for (i=0, rr=w9, cs=w7; i<3; ++i) for (j=0; j<2; ++j) rr[i+j*3] = *cs++;
  /* #45: output[2][0] = @9 */
  casadi_copy(w9, 6, res[2]);
  /* #46: @8 = input[1][3] */
  casadi_copy(arg[1] ? arg[1]+12 : 0, 3, w8);
  /* #47: output[3][0] = @8 */
  casadi_copy(w8, 3, res[3]);
  return 0;
}

/* solver_qpsol:(h[2x2],g[2],a[3x2],lba[3],uba[3],lbx[2],ubx[2],x0[2],lam_x0[2],lam_a0[3],q[0x2],p[])->(x[2],cost,lam_a[3],lam_x[2]) */
static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  OSQPWorkspace *work=casadi_f3_mem[mem];
  casadi_int i, n, offset;
  /* Set objective */
  if (arg[1]) {
    casadi_copy(arg[1], 2, w);
  } else {
    casadi_clear(w, 2);
  }
  if (osqp_update_lin_cost(work, w)) return 1;
  /* Set bounds */
  if (arg[5]) {
    casadi_copy(arg[5], 2, w);
  } else {
    casadi_fill(w, 2, -casadi_inf);
  }
  if (arg[3]) {
    casadi_copy(arg[3], 3, w+2);
  } else {
    casadi_fill(w+2, 3, -casadi_inf);
  }
  if (arg[6]) {
    casadi_copy(arg[6], 2, w+5);
  } else {
    casadi_fill(w+5, 2, casadi_inf);
  }
  if (arg[4]) {
    casadi_copy(arg[4], 3, w+7);
  } else {
    casadi_fill(w+7, 3, casadi_inf);
  }
  if (osqp_update_bounds(work, w, w+5)) return 1;
  /* Project Hessian */
  casadi_tri_project(arg[0], casadi_s1, w, 0);/* Get constraint matrix */
  offset = 0;
  for (i=0; i< 2; ++i) {
    w[3+offset] = 1;
    offset++;
    n = casadi_s8[i+1]-casadi_s8[i];
    casadi_copy(arg[2]+casadi_s8[i], n, w+offset+3);
    offset+= n;
  }
  /* Pass Hessian and constraint matrices */
  if (osqp_update_P_A(work, w, 0, 3, w+3, 0, 8)) return 1;
  if (osqp_warm_start_x(work, arg[7])) return 1;
  if (arg[8]) {
    casadi_copy(arg[8], 2, w);
  } else {
    casadi_clear(w, 2);
  }
  if (arg[9]) {
    casadi_copy(arg[9], 3, w+2);
  } else {
    casadi_clear(w+2, 3);
  }
  if (osqp_warm_start_y(work, w)) return 1;
  if (osqp_solve(work)) return 1;
  if (res[1]) casadi_copy(&work->info->obj_val, 1, res[1]);
  if (res[0]) casadi_copy(work->solution->x, 2, res[0]);
  if (res[3]) casadi_copy(work->solution->y, 2, res[3]);
  if (res[2]) casadi_copy(work->solution->y+2, 3, res[2]);
  if (work->info->status_val != OSQP_SOLVED) {
    return -1000;
  }
  return 0;
  return 0;
}

void casadi_f3_incref(void) {
}

void casadi_f3_decref(void) {
}

int casadi_f3_alloc_mem(void) {
  return casadi_f3_mem_counter++;
}

int casadi_f3_init_mem(int mem) {
  OSQPData data;
  OSQPSettings settings;
  c_int A_colind[3], A_row[8], H_colind[3], H_row[3], i;
  casadi_real dummy[8];
  csc A, H;
  casadi_clear(dummy, 8);
  for (i=0;i<8;++i) A_row[i] = casadi_s9[i];
  for (i=0;i<3;++i) A_colind[i] = casadi_s10[i];
  for (i=0;i<3;++i) H_row[i] = casadi_s11[i];
  for (i=0;i<3;++i) H_colind[i] = casadi_s12[i];
  A.m = 5;
  A.n = 2;
  A.nz = 8;
  A.nzmax = 8;
  A.x = dummy;
  A.i = A_row;
  A.p = A_colind;
  H.m = 2;
  H.n = 2;
  H.nz = 3;
  H.nzmax = 3;
  H.x = dummy;
  H.i = H_row;
  H.p = H_colind;
  data.n = 2;
  data.m = 5;
  data.P = &H;
  data.q = dummy;
  data.A = &A;
  data.l = dummy;
  data.u = dummy;
  osqp_set_default_settings(&settings);
  settings.rho = 0.1;
  settings.sigma = 1e-06;
  settings.scaling = 10;
  settings.adaptive_rho = 1;
  settings.adaptive_rho_interval = 0;
  settings.adaptive_rho_tolerance = 5;
  settings.max_iter = 4000;
  settings.eps_abs = 0.001;
  settings.eps_rel = 0.001;
  settings.eps_prim_inf = 0.0001;
  settings.eps_dual_inf = 0.0001;
  settings.alpha = 1.6;
  settings.delta = 1e-06;
  settings.polish = 1;
  settings.polish_refine_iter = 3;
  settings.verbose = 1;
  settings.scaled_termination = 0;
  settings.check_termination = 25;
  settings.warm_start = 1;
  return osqp_setup(&casadi_f3_mem[mem], &data, &settings)!=0;
}

void casadi_f3_free_mem(int mem) {
  osqp_cleanup(casadi_f3_mem[mem]);
}

int casadi_f3_checkout(void) {
  int mid;
  if (casadi_f3_unused_stack_counter>=0) {
    return casadi_f3_unused_stack[casadi_f3_unused_stack_counter--];
  } else {
    if (casadi_f3_mem_counter==CASADI_MAX_NUM_THREADS) return -1;
    mid = casadi_f3_alloc_mem();
    if (mid<0) return -1;
    if(casadi_f3_init_mem(mid)) return -1;
    return mid;
  }
}

void casadi_f3_release(int mem) {
  casadi_f3_unused_stack[++casadi_f3_unused_stack_counter] = mem;
}

/* constant_qp:(i0[2],i1[15])->(o0) */
static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real w0;
  /* #0: @0 = 0 */
  w0 = 0.;
  /* #1: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  return 0;
}

/* solver:(x0[2],p[15],lbx[2],ubx[2],lbg[3],ubg[3],lam_x0[2],lam_g0[3])->(x[2],f,g[3],lam_x[2],lam_g[3],lam_p[15]) */
static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real **res1=res+6, *rr, *ss, *tt;
  const casadi_real **arg1=arg+8, *cs;
  int flag, mid;
  casadi_real *w0=w+36, *w1=w+38, *w2=w+53, *w3=w+57, *w4=w+59, *w5=w+65, *w6=w+68, *w7=w+71, *w8=w+74, *w9=w+76, *w10=w+78, *w11=w+80, *w14=w+83, w15, *w16=w+86, *w17=w+89, w18;
  /* #0: @0 = input[0][0] */
  casadi_copy(arg[0], 2, w0);
  /* #1: @1 = input[1][0] */
  casadi_copy(arg[1], 15, w1);
  /* #2: {@2, @3, @4, @5, NULL, NULL} = solver_qp(@0, @1) */
  arg1[0]=w0;
  arg1[1]=w1;
  res1[0]=w2;
  res1[1]=w3;
  res1[2]=w4;
  res1[3]=w5;
  res1[4]=0;
  res1[5]=0;
  if (casadi_f2(arg1, res1, iw, w, 0)) return 1;
  /* #3: @6 = input[4][0] */
  casadi_copy(arg[4], 3, w6);
  /* #4: @6 = (@6-@5) */
  for (i=0, rr=w6, cs=w5; i<3; ++i) (*rr++) -= (*cs++);
  /* #5: @7 = input[5][0] */
  casadi_copy(arg[5], 3, w7);
  /* #6: @7 = (@7-@5) */
  for (i=0, rr=w7, cs=w5; i<3; ++i) (*rr++) -= (*cs++);
  /* #7: @8 = input[2][0] */
  casadi_copy(arg[2], 2, w8);
  /* #8: @9 = input[3][0] */
  casadi_copy(arg[3], 2, w9);
  /* #9: @10 = input[6][0] */
  casadi_copy(arg[6], 2, w10);
  /* #10: @11 = input[7][0] */
  casadi_copy(arg[7], 3, w11);
  /* #11: @12 = 0x2 */
  /* #12: @13 = 0x0 */
  /* #13: {@14, @15, @16, @17} = solver_qpsol(@2, @3, @4, @6, @7, @8, @9, @0, @10, @11, @12, @13) */
  arg1[0]=w2;
  arg1[1]=w3;
  arg1[2]=w4;
  arg1[3]=w6;
  arg1[4]=w7;
  arg1[5]=w8;
  arg1[6]=w9;
  arg1[7]=w0;
  arg1[8]=w10;
  arg1[9]=w11;
  arg1[10]=0;
  arg1[11]=0;
  res1[0]=w14;
  res1[1]=(&w15);
  res1[2]=w16;
  res1[3]=w17;
  mid = casadi_f3_checkout();
  if (mid<0) return 1;
  flag = casadi_f3(arg1, res1, iw, w, mid);
  casadi_f3_release(mid);
  if (flag) return 1;
  /* #14: output[0][0] = @14 */
  casadi_copy(w14, 2, res[0]);
  /* #15: @18 = constant_qp(@0, @1) */
  arg1[0]=w0;
  arg1[1]=w1;
  res1[0]=(&w18);
  if (casadi_f4(arg1, res1, iw, w, 0)) return 1;
  /* #16: @18 = (@18+@15) */
  w18 += w15;
  /* #17: output[1][0] = @18 */
  if (res[1]) res[1][0] = w18;
  /* #18: @6 = zeros(3x1) */
  casadi_clear(w6, 3);
  /* #19: @6 = mac(@4,@14,@6) */
  for (i=0, rr=w6; i<1; ++i) for (j=0; j<3; ++j, ++rr) for (k=0, ss=w4+j, tt=w14+i*2; k<2; ++k) *rr += ss[k*3]**tt++;
  /* #20: @6 = (@6+@5) */
  for (i=0, rr=w6, cs=w5; i<3; ++i) (*rr++) += (*cs++);
  /* #21: output[2][0] = @6 */
  casadi_copy(w6, 3, res[2]);
  /* #22: output[3][0] = @17 */
  casadi_copy(w17, 2, res[3]);
  /* #23: output[4][0] = @16 */
  casadi_copy(w16, 3, res[4]);
  /* #24: @1 = nan(15x1) */
  casadi_fill(w1, 15, casadi_nan);
  /* #25: output[5][0] = @1 */
  casadi_copy(w1, 15, res[5]);
  return 0;
}

void casadi_f1_incref(void) {
  casadi_f3_incref();
}

void casadi_f1_decref(void) {
  casadi_f3_decref();
}

/* helper:(i0[2],i1[15],i2[3])->(o0[2]) */
static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real *w0=w+0;
  /* #0: @0 = input[0][0] */
  casadi_copy(arg[0], 2, w0);
  /* #1: output[0][0] = @0 */
  casadi_copy(w0, 2, res[0]);
  return 0;
}

/* solveQP:(i0[2x2],i1[2],i2[3x2],i3[3])->(o0[2]) */
static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i;
  casadi_real **res1=res+1, *rr;
  const casadi_real **arg1=arg+4, *cs;
  casadi_real *w0=w+92, *w1=w+94, *w2=w+98, *w3=w+100, *w4=w+106, *w5=w+109, *w6=w+124, *w7=w+126, *w8=w+129, *w9=w+131, *w10=w+134, *w11=w+136;
  /* #0: @0 = zeros(2x1) */
  casadi_clear(w0, 2);
  /* #1: @1 = input[0][0] */
  casadi_copy(arg[0], 4, w1);
  /* #2: @1 = vec(@1) */
  /* #3: @2 = input[1][0] */
  casadi_copy(arg[1], 2, w2);
  /* #4: @3 = input[2][0] */
  casadi_copy(arg[2], 6, w3);
  /* #5: @3 = vec(@3) */
  /* #6: @4 = input[3][0] */
  casadi_copy(arg[3], 3, w4);
  /* #7: @5 = vertcat(@1, @2, @3, @4) */
  rr=w5;
  for (i=0, cs=w1; i<4; ++i) *rr++ = *cs++;
  for (i=0, cs=w2; i<2; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<6; ++i) *rr++ = *cs++;
  for (i=0, cs=w4; i<3; ++i) *rr++ = *cs++;
  /* #8: @2 = -inf(2x1) */
  casadi_fill(w2, 2, -casadi_inf);
  /* #9: @6 = inf(2x1) */
  casadi_fill(w6, 2, casadi_inf);
  /* #10: @4 = -inf(3x1) */
  casadi_fill(w4, 3, -casadi_inf);
  /* #11: @7 = zeros(3x1) */
  casadi_clear(w7, 3);
  /* #12: @8 = zeros(2x1) */
  casadi_clear(w8, 2);
  /* #13: @9 = zeros(3x1) */
  casadi_clear(w9, 3);
  /* #14: {@10, NULL, NULL, NULL, @11, NULL} = solver(@0, @5, @2, @6, @4, @7, @8, @9) */
  arg1[0]=w0;
  arg1[1]=w5;
  arg1[2]=w2;
  arg1[3]=w6;
  arg1[4]=w4;
  arg1[5]=w7;
  arg1[6]=w8;
  arg1[7]=w9;
  res1[0]=w10;
  res1[1]=0;
  res1[2]=0;
  res1[3]=0;
  res1[4]=w11;
  res1[5]=0;
  if (casadi_f1(arg1, res1, iw, w, 0)) return 1;
  /* #15: @0 = helper(@10, @5, @11) */
  arg1[0]=w10;
  arg1[1]=w5;
  arg1[2]=w11;
  res1[0]=w0;
  if (casadi_f5(arg1, res1, iw, w, 0)) return 1;
  /* #16: output[0][0] = @0 */
  casadi_copy(w0, 2, res[0]);
  return 0;
}

void casadi_f0_incref(void) {
  casadi_f1_incref();
}

void casadi_f0_decref(void) {
  casadi_f1_decref();
}

CASADI_SYMBOL_EXPORT int solveQP(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
  return casadi_f0(arg, res, iw, w, mem);
}

CASADI_SYMBOL_EXPORT int solveQP_alloc_mem(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT int solveQP_init_mem(int mem) {
  return 0;
}

CASADI_SYMBOL_EXPORT void solveQP_free_mem(int mem) {
}

CASADI_SYMBOL_EXPORT int solveQP_checkout(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT void solveQP_release(int mem) {
}

CASADI_SYMBOL_EXPORT void solveQP_incref(void) {
  casadi_f1_incref();
}

CASADI_SYMBOL_EXPORT void solveQP_decref(void) {
  casadi_f1_decref();
}

CASADI_SYMBOL_EXPORT casadi_int solveQP_n_in(void) { return 4;}

CASADI_SYMBOL_EXPORT casadi_int solveQP_n_out(void) { return 1;}

CASADI_SYMBOL_EXPORT casadi_real solveQP_default_in(casadi_int i) {
  switch (i) {
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* solveQP_name_in(casadi_int i) {
  switch (i) {
    case 0: return "i0";
    case 1: return "i1";
    case 2: return "i2";
    case 3: return "i3";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* solveQP_name_out(casadi_int i) {
  switch (i) {
    case 0: return "o0";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* solveQP_sparsity_in(casadi_int i) {
  switch (i) {
    case 0: return casadi_s1;
    case 1: return casadi_s13;
    case 2: return casadi_s6;
    case 3: return casadi_s4;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* solveQP_sparsity_out(casadi_int i) {
  switch (i) {
    case 0: return casadi_s13;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT int solveQP_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 24;
  if (sz_res) *sz_res = 14;
  if (sz_iw) *sz_iw = 0;
  if (sz_w) *sz_w = 139;
  return 0;
}

CASADI_SYMBOL_EXPORT int solveQP_work_bytes(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 24*sizeof(const casadi_real*);
  if (sz_res) *sz_res = 14*sizeof(casadi_real*);
  if (sz_iw) *sz_iw = 0*sizeof(casadi_int);
  if (sz_w) *sz_w = 139*sizeof(casadi_real);
  return 0;
}

CASADI_SYMBOL_EXPORT casadi_functions* solveQP_functions(void) {
  static casadi_functions fun = {
    solveQP_incref,
    solveQP_decref,
    solveQP_checkout,
    solveQP_release,
    solveQP_default_in,
    solveQP_n_in,
    solveQP_n_out,
    solveQP_name_in,
    solveQP_name_out,
    solveQP_sparsity_in,
    solveQP_sparsity_out,
    solveQP_work,
    solveQP
  };
  return &fun;
}

#ifdef __cplusplus
} /* extern "C" */
#endif
